package handlers

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"github.com/zishang520/socket.io-client-go/socket"

	"ccagent/core"
	"ccagent/core/log"
	"ccagent/models"
	"ccagent/services"
	"ccagent/usecases"
	"ccagent/utils"
)

type MessageHandler struct {
	claudeService *services.ClaudeService
	gitUseCase    *usecases.GitUseCase
	appState      *models.AppState
}

func NewMessageHandler(claudeService *services.ClaudeService, gitUseCase *usecases.GitUseCase, appState *models.AppState) *MessageHandler {
	return &MessageHandler{
		claudeService: claudeService,
		gitUseCase:    gitUseCase,
		appState:      appState,
	}
}

func (mh *MessageHandler) HandleMessage(msg models.BaseMessage, socketClient *socket.Socket) {
	switch msg.Type {
	case models.MessageTypeStartConversation:
		if err := mh.handleStartConversation(msg, socketClient); err != nil {
			// Extract SlackMessageID from payload for error reporting
			var payload models.StartConversationPayload
			slackMessageID := ""
			if unmarshalErr := unmarshalPayload(msg.Payload, &payload); unmarshalErr == nil {
				slackMessageID = payload.SlackMessageID
			}
			if sendErr := mh.sendErrorMessage(socketClient, err, slackMessageID); sendErr != nil {
				log.Error("Failed to send error message: %v", sendErr)
			}
		}
	case models.MessageTypeUserMessage:
		if err := mh.handleUserMessage(msg, socketClient); err != nil {
			// Extract SlackMessageID from payload for error reporting
			var payload models.UserMessagePayload
			slackMessageID := ""
			if unmarshalErr := unmarshalPayload(msg.Payload, &payload); unmarshalErr == nil {
				slackMessageID = payload.SlackMessageID
			}
			if sendErr := mh.sendErrorMessage(socketClient, err, slackMessageID); sendErr != nil {
				log.Error("Failed to send error message: %v", sendErr)
			}
		}
	case models.MessageTypeCheckIdleJobs:
		if err := mh.handleCheckIdleJobs(msg, socketClient); err != nil {
			log.Info("‚ùå Error handling CheckIdleJobs message: %v", err)
		}
	default:
		log.Info("‚ö†Ô∏è Unhandled message type: %s", msg.Type)
	}
}

func (mh *MessageHandler) handleStartConversation(msg models.BaseMessage, socketClient *socket.Socket) error {
	log.Info("üìã Starting to handle start conversation message")
	var payload models.StartConversationPayload
	if err := unmarshalPayload(msg.Payload, &payload); err != nil {
		log.Info("‚ùå Failed to unmarshal start conversation payload: %v", err)
		return fmt.Errorf("failed to unmarshal start conversation payload: %w", err)
	}

	// Send processing slack message notification that agent is starting to process
	if err := mh.sendProcessingSlackMessage(socketClient, payload.SlackMessageID); err != nil {
		log.Info("‚ùå Failed to send processing slack message notification: %v", err)
		return fmt.Errorf("failed to send processing slack message notification: %w", err)
	}

	log.Info("üöÄ Starting new conversation with message: %s", payload.Message)

	// Prepare Git environment for new conversation - FAIL if this doesn't work
	branchName, err := mh.gitUseCase.PrepareForNewConversation(payload.Message)
	if err != nil {
		log.Error("‚ùå Failed to prepare Git environment: %v", err)
		return fmt.Errorf("failed to prepare Git environment: %w", err)
	}

	behaviourInstructions := `You are a claude code instance which will be referred to by the user as "Claude Control" for this session. When someone calls you claude control, they refer to you.

You are being interacted with over Slack (the software). I want you to adjust your responses to account for this. In particular:
- CRITICAL: Keep ALL responses under 800 characters maximum - this is a hard limit for Slack readability
- Focus on high-level summaries and avoid implementation details unless specifically requested
- Structure your responses in sections split via bold text instead of using markdown headings because slack doesnt support markdown headings
- Use the following Markdown formatting rules for all of your responses:
	- Bold text: *example*
	- Italic text: _example_
	- Strikethrough text: ~example~
	- Block quotes: > example
	- Bulleted list - - one\n - two\n - three
	- Inline code blocks: ` + "`example`" + `
	- Full code blocks: ` + "```example```" + `
- Do not use any other sort of markdown format except the ones listed above
- Do not show any specific language in code blocks because Slack doesn't support syntax highlighting
    - This is incorrect - ` + "```python\nexample\n```" + `
    - This is correct - ` + "```\nexample\n```" + `
- Especially be careful when using bold text:
    - This is incorrect - **example**
	- This is correct - *example*
- Use emojis liberally to draw attention to the relevant pieces of your message that are most important
- Be more explicit about errors and failures with clear emoji indicators
- Use clear file paths with line numbers for easy navigation

IMPORTANT: If you are editing a pull request description, never include or override the "Generated by [Claude Control](https://claudecontrol.com) from this [slack thread]" footer. The system will add this footer automatically. Do not include any "Generated by Claude Code" or similar footer text in PR descriptions.

CRITICAL: Never autonomously create git commits or pull requests unless explicitly asked to do so by the user. Wait for explicit instructions before making any commits or creating PRs.
`

	claudeResult, err := mh.claudeService.StartNewConversationWithSystemPrompt(payload.Message, behaviourInstructions)
	if err != nil {
		log.Info("‚ùå Error starting Claude session: %v", err)
		systemErr := mh.sendSystemMessage(socketClient, fmt.Sprintf("ccagent encountered error: %v", err), payload.SlackMessageID)
		if systemErr != nil {
			log.Error("‚ùå Failed to send system message for Claude error: %v", systemErr)
		}
		return fmt.Errorf("error starting Claude session: %w", err)
	}

	// Auto-commit changes if needed
	commitResult, err := mh.gitUseCase.AutoCommitChangesIfNeeded(payload.SlackMessageLink)
	if err != nil {
		log.Info("‚ùå Auto-commit failed: %v", err)
		return fmt.Errorf("auto-commit failed: %w", err)
	}

	// Update JobData with conversation info (use commitResult.BranchName if available, otherwise branchName)
	finalBranchName := branchName
	if commitResult != nil && commitResult.BranchName != "" {
		finalBranchName = commitResult.BranchName
	}

	// Extract PR ID from commit result if available
	prID := ""
	if commitResult != nil && commitResult.PullRequestID != "" {
		prID = commitResult.PullRequestID
	}

	mh.appState.UpdateJobData(payload.JobID, models.JobData{
		JobID:           payload.JobID,
		BranchName:      finalBranchName,
		ClaudeSessionID: claudeResult.SessionID,
		PullRequestID:   prID,
		UpdatedAt:       time.Now(),
	})

	// Send assistant response back first
	assistantPayload := models.AssistantMessagePayload{
		JobID:          payload.JobID,
		Message:        claudeResult.Output,
		SlackMessageID: payload.SlackMessageID,
	}

	assistantMsg := models.BaseMessage{
		ID:      core.NewID("msg"),
		Type:    models.MessageTypeAssistantMessage,
		Payload: assistantPayload,
	}
	if err := socketClient.Emit("cc_message", assistantMsg); err != nil {
		log.Info("‚ùå Failed to send assistant response: %v", err)
		return fmt.Errorf("failed to send assistant response: %w", err)
	}

	log.Info("ü§ñ Sent assistant response (message ID: %s)", assistantMsg.ID)

	// Add delay to ensure git activity message comes after assistant message
	time.Sleep(200 * time.Millisecond)

	// Send system message after assistant message for git activity
	if err := mh.sendGitActivitySystemMessage(socketClient, commitResult, payload.SlackMessageID); err != nil {
		log.Info("‚ùå Failed to send git activity system message: %v", err)
		return fmt.Errorf("failed to send git activity system message: %w", err)
	}

	// Validate and restore PR description footer if needed
	if err := mh.gitUseCase.ValidateAndRestorePRDescriptionFooter(payload.SlackMessageLink); err != nil {
		log.Info("‚ùå Failed to validate PR description footer: %v", err)
		return fmt.Errorf("failed to validate PR description footer: %w", err)
	}

	log.Info("üìã Completed successfully - handled start conversation message")
	return nil
}

func (mh *MessageHandler) handleUserMessage(msg models.BaseMessage, socketClient *socket.Socket) error {
	log.Info("üìã Starting to handle user message")
	var payload models.UserMessagePayload
	if err := unmarshalPayload(msg.Payload, &payload); err != nil {
		log.Info("‚ùå Failed to unmarshal user message payload: %v", err)
		return fmt.Errorf("failed to unmarshal user message payload: %w", err)
	}

	// Send processing slack message notification that agent is starting to process
	if err := mh.sendProcessingSlackMessage(socketClient, payload.SlackMessageID); err != nil {
		log.Info("‚ùå Failed to send processing slack message notification: %v", err)
		return fmt.Errorf("failed to send processing slack message notification: %w", err)
	}

	log.Info("üí¨ Continuing conversation with message: %s", payload.Message)

	// Get the current job data to retrieve the Claude session ID and branch
	jobData, exists := mh.appState.GetJobData(payload.JobID)
	if !exists {
		log.Info("‚ùå JobID %s not found in AppState", payload.JobID)
		return fmt.Errorf("job %s not found - conversation may have been started elsewhere", payload.JobID)
	}

	sessionID := jobData.ClaudeSessionID
	if sessionID == "" {
		log.Info("‚ùå No Claude session ID found for job %s", payload.JobID)
		return fmt.Errorf("no active Claude session found for job %s", payload.JobID)
	}

	// Assert that BranchName is never empty
	utils.AssertInvariant(jobData.BranchName != "", "BranchName must not be empty for job "+payload.JobID)

	// Switch to the job's branch before continuing the conversation
	if err := mh.gitUseCase.SwitchToJobBranch(jobData.BranchName); err != nil {
		log.Error("‚ùå Failed to switch to job branch %s: %v", jobData.BranchName, err)
		return fmt.Errorf("failed to switch to job branch %s: %w", jobData.BranchName, err)
	}
	log.Info("‚úÖ Successfully switched to job branch: %s", jobData.BranchName)

	claudeResult, err := mh.claudeService.ContinueConversation(sessionID, payload.Message)
	if err != nil {
		log.Info("‚ùå Error continuing Claude session: %v", err)
		systemErr := mh.sendSystemMessage(socketClient, fmt.Sprintf("ccagent encountered error: %v", err), payload.SlackMessageID)
		if systemErr != nil {
			log.Error("‚ùå Failed to send system message for Claude error: %v", systemErr)
		}
		return fmt.Errorf("error continuing Claude session: %w", err)
	}

	// Auto-commit changes if needed
	commitResult, err := mh.gitUseCase.AutoCommitChangesIfNeeded(payload.SlackMessageLink)
	if err != nil {
		log.Info("‚ùå Auto-commit failed: %v", err)
		return fmt.Errorf("auto-commit failed: %w", err)
	}

	// Update JobData with latest session ID and branch name from commit result
	finalBranchName := jobData.BranchName
	if commitResult != nil && commitResult.BranchName != "" {
		finalBranchName = commitResult.BranchName
	}

	// Extract PR ID from existing job data or commit result
	prID := jobData.PullRequestID
	if commitResult != nil && commitResult.PullRequestID != "" {
		prID = commitResult.PullRequestID
	}

	mh.appState.UpdateJobData(payload.JobID, models.JobData{
		JobID:           payload.JobID,
		BranchName:      finalBranchName,
		ClaudeSessionID: claudeResult.SessionID,
		PullRequestID:   prID,
		UpdatedAt:       time.Now(),
	})

	// Send assistant response back first
	assistantPayload := models.AssistantMessagePayload{
		JobID:          payload.JobID,
		Message:        claudeResult.Output,
		SlackMessageID: payload.SlackMessageID,
	}

	assistantMsg := models.BaseMessage{
		ID:      core.NewID("msg"),
		Type:    models.MessageTypeAssistantMessage,
		Payload: assistantPayload,
	}
	if err := socketClient.Emit("cc_message", assistantMsg); err != nil {
		log.Info("‚ùå Failed to send assistant response: %v", err)
		return fmt.Errorf("failed to send assistant response: %w", err)
	}

	log.Info("ü§ñ Sent assistant response (message ID: %s)", assistantMsg.ID)

	// Add delay to ensure git activity message comes after assistant message
	time.Sleep(200 * time.Millisecond)

	// Send system message after assistant message for git activity
	if err := mh.sendGitActivitySystemMessage(socketClient, commitResult, payload.SlackMessageID); err != nil {
		log.Info("‚ùå Failed to send git activity system message: %v", err)
		return fmt.Errorf("failed to send git activity system message: %w", err)
	}

	// Validate and restore PR description footer if needed
	if err := mh.gitUseCase.ValidateAndRestorePRDescriptionFooter(payload.SlackMessageLink); err != nil {
		log.Info("‚ùå Failed to validate PR description footer: %v", err)
		return fmt.Errorf("failed to validate PR description footer: %w", err)
	}

	log.Info("üìã Completed successfully - handled user message")
	return nil
}

func (mh *MessageHandler) handleCheckIdleJobs(msg models.BaseMessage, socketClient *socket.Socket) error {
	log.Info("üìã Starting to handle check idle jobs message")
	var payload models.CheckIdleJobsPayload
	if err := unmarshalPayload(msg.Payload, &payload); err != nil {
		log.Info("‚ùå Failed to unmarshal check idle jobs payload: %v", err)
		return fmt.Errorf("failed to unmarshal check idle jobs payload: %w", err)
	}

	log.Info("üîç Checking all assigned jobs for idleness")

	// Get all job data from app state
	allJobData := mh.appState.GetAllJobs()
	if len(allJobData) == 0 {
		log.Info("üìã No jobs assigned to this agent")
		return nil
	}

	log.Info("üîç Found %d jobs assigned to this agent", len(allJobData))

	// Check each job for idleness
	for jobID, jobData := range allJobData {
		log.Info("üîç Checking job %s on branch %s", jobID, jobData.BranchName)

		if err := mh.checkJobIdleness(jobID, jobData, socketClient); err != nil {
			log.Info("‚ùå Failed to check idleness for job %s: %v", jobID, err)
			// Continue checking other jobs even if one fails
			continue
		}
	}

	log.Info("üìã Completed successfully - checked all jobs for idleness")
	return nil
}

func (mh *MessageHandler) checkJobIdleness(jobID string, jobData models.JobData, socketClient *socket.Socket) error {
	log.Info("üìã Starting to check idleness for job %s", jobID)

	var prStatus string
	var err error

	// Use stored PR ID if available, otherwise fall back to branch-based check
	if jobData.PullRequestID != "" {
		log.Info("‚ÑπÔ∏è Using stored PR ID %s for job %s", jobData.PullRequestID, jobID)
		prStatus, err = mh.gitUseCase.CheckPRStatusByID(jobData.PullRequestID)
		if err != nil {
			log.Error("‚ùå Failed to check PR status by ID %s: %v", jobData.PullRequestID, err)
			return fmt.Errorf("failed to check PR status by ID %s: %w", jobData.PullRequestID, err)
		}
	} else {
		log.Info("‚ÑπÔ∏è No stored PR ID for job %s, using branch-based check", jobID)
		prStatus, err = mh.gitUseCase.CheckPRStatus(jobData.BranchName)
		if err != nil {
			log.Error("‚ùå Failed to check PR status for branch %s: %v", jobData.BranchName, err)
			return fmt.Errorf("failed to check PR status for branch %s: %w", jobData.BranchName, err)
		}
	}

	var reason string
	var shouldComplete bool

	switch prStatus {
	case "merged":
		reason = "Job complete - Pull request was merged"
		shouldComplete = true
		log.Info("‚úÖ Job %s PR was merged - marking as complete", jobID)
	case "closed":
		reason = "Job complete - Pull request was closed"
		shouldComplete = true
		log.Info("‚úÖ Job %s PR was closed - marking as complete", jobID)
	case "open":
		log.Info("‚ÑπÔ∏è Job %s has open PR - not marking as complete", jobID)
		shouldComplete = false
	case "no_pr":
		log.Info("‚ÑπÔ∏è Job %s has no PR - checking timeout", jobID)
		jobData, exists := mh.appState.GetJobData(jobID)
		if !exists {
			log.Info("‚ùå Job %s not found in app state - cannot check idleness", jobID)
			return fmt.Errorf("job %s not found in app state", jobID)
		}

		if jobData.UpdatedAt.Add(1 * time.Hour).After(time.Now()) {
			log.Info("‚ÑπÔ∏è Job %s has no PR but is still active - not marking as complete", jobID)
			shouldComplete = false
		} else {
			log.Info("‚è∞ Job %s has no PR and is idle - marking as complete", jobID)
			reason = "Job complete - Thread is inactive"
			shouldComplete = true
		}
	default:
		log.Info("‚ÑπÔ∏è Job %s PR status unclear (%s) - keeping active", jobID, prStatus)
		shouldComplete = false
	}

	if shouldComplete {
		if err := mh.sendJobCompleteMessage(socketClient, jobID, reason); err != nil {
			log.Error("‚ùå Failed to send job complete message for job %s: %v", jobID, err)
			return fmt.Errorf("failed to send job complete message: %w", err)
		}

		// Remove job from app state since it's complete
		mh.appState.RemoveJob(jobID)
		log.Info("üóëÔ∏è Removed completed job %s from app state", jobID)
	}

	log.Info("üìã Completed successfully - checked idleness for job %s", jobID)
	return nil
}

func (mh *MessageHandler) sendJobCompleteMessage(socketClient *socket.Socket, jobID, reason string) error {
	log.Info("üìã Sending job complete message for job %s with reason: %s", jobID, reason)

	payload := models.JobCompletePayload{
		JobID:  jobID,
		Reason: reason,
	}

	jobMsg := models.BaseMessage{
		ID:      core.NewID("msg"),
		Type:    models.MessageTypeJobComplete,
		Payload: payload,
	}
	if err := socketClient.Emit("cc_message", jobMsg); err != nil {
		log.Info("‚ùå Failed to send job complete message: %v", err)
		return fmt.Errorf("failed to send job complete message: %w", err)
	}

	log.Info("üì§ Sent job complete message for job: %s (message ID: %s)", jobID, jobMsg.ID)

	return nil
}

func (mh *MessageHandler) sendSystemMessage(socketClient *socket.Socket, message, slackMessageID string) error {
	payload := models.SystemMessagePayload{
		Message:        message,
		SlackMessageID: slackMessageID,
	}

	sysMsg := models.BaseMessage{
		ID:      core.NewID("msg"),
		Type:    models.MessageTypeSystemMessage,
		Payload: payload,
	}
	if err := socketClient.Emit("cc_message", sysMsg); err != nil {
		log.Info("‚ùå Failed to send system message: %v", err)
		return fmt.Errorf("failed to send system message: %w", err)
	}

	log.Info("‚öôÔ∏è Sent system message: %s (message ID: %s)", message, sysMsg.ID)

	return nil
}

// sendErrorMessage sends an error as a system message. The Claude service handles
// all error processing internally, so we just need to format and send the error.
func (mh *MessageHandler) sendErrorMessage(socketClient *socket.Socket, err error, slackMessageID string) error {
	messageToSend := fmt.Sprintf("ccagent encountered error: %v", err)
	return mh.sendSystemMessage(socketClient, messageToSend, slackMessageID)
}

func (mh *MessageHandler) sendProcessingSlackMessage(socketClient *socket.Socket, slackMessageID string) error {
	processingSlackMessageMsg := models.BaseMessage{
		ID:   core.NewID("msg"),
		Type: models.MessageTypeProcessingSlackMessage,
		Payload: models.ProcessingSlackMessagePayload{
			SlackMessageID: slackMessageID,
		},
	}

	if err := socketClient.Emit("cc_message", processingSlackMessageMsg); err != nil {
		log.Info("‚ùå Failed to send processing slack message notification: %v", err)
		return fmt.Errorf("failed to send processing slack message notification: %w", err)
	}

	log.Info("üîî Sent processing slack message notification for message: %s", slackMessageID)
	return nil
}

func extractPRNumber(prURL string) string {
	if prURL == "" {
		return ""
	}

	// Extract PR number from URL like https://github.com/user/repo/pull/1234
	parts := strings.Split(prURL, "/")
	if len(parts) > 0 && parts[len(parts)-1] != "" {
		return "#" + parts[len(parts)-1]
	}

	return ""
}

func (mh *MessageHandler) sendGitActivitySystemMessage(socketClient *socket.Socket, commitResult *usecases.AutoCommitResult, slackMessageID string) error {
	if commitResult == nil {
		return nil
	}

	if commitResult.JustCreatedPR && commitResult.PullRequestLink != "" {
		// New PR created
		message := fmt.Sprintf("Agent opened a <%s|pull request>", commitResult.PullRequestLink)
		if err := mh.sendSystemMessage(socketClient, message, slackMessageID); err != nil {
			log.Info("‚ùå Failed to send PR creation system message: %v", err)
			return fmt.Errorf("failed to send PR creation system message: %w", err)
		}
	} else if !commitResult.JustCreatedPR && commitResult.CommitHash != "" && commitResult.RepositoryURL != "" {
		// Commit added to existing PR
		shortHash := commitResult.CommitHash
		if len(shortHash) > 7 {
			shortHash = shortHash[:7]
		}
		commitURL := fmt.Sprintf("%s/commit/%s", commitResult.RepositoryURL, commitResult.CommitHash)
		message := fmt.Sprintf("New commit added: <%s|%s>", commitURL, shortHash)

		// Add PR link if available
		if commitResult.PullRequestLink != "" {
			prNumber := extractPRNumber(commitResult.PullRequestLink)
			if prNumber != "" {
				message += fmt.Sprintf(" in <%s|%s>", commitResult.PullRequestLink, prNumber)
			}
		}

		if err := mh.sendSystemMessage(socketClient, message, slackMessageID); err != nil {
			log.Info("‚ùå Failed to send commit system message: %v", err)
			return fmt.Errorf("failed to send commit system message: %w", err)
		}
	}

	return nil
}

func unmarshalPayload(payload any, target any) error {
	if payload == nil {
		return nil
	}

	payloadBytes, err := json.Marshal(payload)
	if err != nil {
		return err
	}

	return json.Unmarshal(payloadBytes, target)
}
